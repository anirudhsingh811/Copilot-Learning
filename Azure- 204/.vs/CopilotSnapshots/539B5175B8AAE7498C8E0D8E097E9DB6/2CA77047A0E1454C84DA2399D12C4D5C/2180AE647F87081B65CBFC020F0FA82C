using Microsoft.Azure.Cosmos;
using Microsoft.Extensions.Logging;
using System.Text.Json;

namespace AZ204.Storage.CosmosDB;

/// <summary>
/// Comprehensive Cosmos DB operations with best practices
/// Covers: CRUD, partitioning, queries, change feed, stored procedures
/// </summary>
public class CosmosDbManager
{
    private readonly ILogger<CosmosDbManager> _logger;
    private readonly CosmosClient _cosmosClient;

    public CosmosDbManager(ILogger<CosmosDbManager> logger, CosmosClient cosmosClient)
    {
        _logger = logger;
        _cosmosClient = cosmosClient;
    }

    /// <summary>
    /// Creates a database with specified throughput
    /// </summary>
    public async Task<Database> CreateDatabaseAsync(string databaseId, int? throughput = null)
    {
        _logger.LogInformation("Creating database: {DatabaseId}", databaseId);

        DatabaseResponse response;
        if (throughput.HasValue)
        {
            response = await _cosmosClient.CreateDatabaseIfNotExistsAsync(
                databaseId,
                ThroughputProperties.CreateManualThroughput(throughput.Value));
        }
        else
        {
            response = await _cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);
        }

        _logger.LogInformation("Database created. Request charge: {RU} RU/s", response.RequestCharge);
        return response.Database;
    }

    /// <summary>
    /// Creates a container with partition key
    /// </summary>
    public async Task<Container> CreateContainerAsync(
        string databaseId,
        string containerId,
        string partitionKeyPath,
        int? throughput = null)
    {
        _logger.LogInformation("Creating container: {ContainerId} with partition key: {PartitionKey}",
            containerId, partitionKeyPath);

        var database = _cosmosClient.GetDatabase(databaseId);

        ContainerProperties containerProperties = new()
        {
            Id = containerId,
            PartitionKeyPath = partitionKeyPath
        };

        ContainerResponse response;
        if (throughput.HasValue)
        {
            response = await database.CreateContainerIfNotExistsAsync(
                containerProperties,
                ThroughputProperties.CreateManualThroughput(throughput.Value));
        }
        else
        {
            response = await database.CreateContainerIfNotExistsAsync(containerProperties);
        }

        _logger.LogInformation("Container created. Request charge: {RU} RU/s", response.RequestCharge);
        return response.Container;
    }

    /// <summary>
    /// Insert or update item (Upsert)
    /// </summary>
    public async Task<T> UpsertItemAsync<T>(
        string databaseId,
        string containerId,
        T item,
        PartitionKey partitionKey)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        var response = await container.UpsertItemAsync(item, partitionKey);

        _logger.LogInformation("Item upserted. RU consumed: {RU}", response.RequestCharge);
        return response.Resource;
    }

    /// <summary>
    /// Read item by ID and partition key
    /// </summary>
    public async Task<T?> ReadItemAsync<T>(
        string databaseId,
        string containerId,
        string itemId,
        PartitionKey partitionKey)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        try
        {
            var response = await container.ReadItemAsync<T>(itemId, partitionKey);
            _logger.LogInformation("Item read. RU consumed: {RU}", response.RequestCharge);
            return response.Resource;
        }
        catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            _logger.LogWarning("Item not found: {ItemId}", itemId);
            return default;
        }
    }

    /// <summary>
    /// Query items using SQL syntax
    /// </summary>
    public async Task<List<T>> QueryItemsAsync<T>(
        string databaseId,
        string containerId,
        string query,
        PartitionKey? partitionKey = null)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        var queryDefinition = new QueryDefinition(query);
        var queryOptions = new QueryRequestOptions();

        if (partitionKey.HasValue)
        {
            queryOptions.PartitionKey = partitionKey.Value;
        }

        var results = new List<T>();
        double totalRU = 0;

        using var resultSetIterator = container.GetItemQueryIterator<T>(queryDefinition, requestOptions: queryOptions);

        while (resultSetIterator.HasMoreResults)
        {
            var response = await resultSetIterator.ReadNextAsync();
            results.AddRange(response);
            totalRU += response.RequestCharge;
        }

        _logger.LogInformation("Query executed. Items: {Count}, Total RU: {RU}",
            results.Count, totalRU);

        return results;
    }

    /// <summary>
    /// Delete item
    /// </summary>
    public async Task DeleteItemAsync<T>(
        string databaseId,
        string containerId,
        string itemId,
        PartitionKey partitionKey)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        var response = await container.DeleteItemAsync<T>(itemId, partitionKey);
        _logger.LogInformation("Item deleted. RU consumed: {RU}", response.RequestCharge);
    }

    /// <summary>
    /// Batch operations (transactional)
    /// </summary>
    public async Task<TransactionalBatchResponse> ExecuteBatchAsync(
        string databaseId,
        string containerId,
        PartitionKey partitionKey,
        List<(string operation, object item)> operations)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        var batch = container.CreateTransactionalBatch(partitionKey);

        foreach (var (operation, item) in operations)
        {
            switch (operation.ToLower())
            {
                case "create":
                    batch.CreateItem(item);
                    break;
                case "upsert":
                    batch.UpsertItem(item);
                    break;
                case "replace":
                    var itemWithId = item as dynamic;
                    batch.ReplaceItem(itemWithId?.id ?? throw new ArgumentException("Item must have id"), item);
                    break;
                case "delete":
                    var deleteId = item as string ?? throw new ArgumentException("Delete operation requires string id");
                    batch.DeleteItem(deleteId);
                    break;
            }
        }

        var response = await batch.ExecuteAsync();

        _logger.LogInformation("Batch executed. Success: {Success}, RU: {RU}",
            response.IsSuccessStatusCode, response.RequestCharge);

        return response;
    }

    /// <summary>
    /// Change feed processor pattern (simplified for demo purposes)
    /// </summary>
    public async Task<string> StartChangeFeedProcessorDemoAsync(
        string databaseId,
        string monitoredContainer,
        string leaseContainer,
        string processorName)
    {
        _logger.LogInformation("Change feed processor demo: {ProcessorName}", processorName);
        
        // Note: Full implementation requires proper delegate signature
        // This is a simplified demo version
        
        return await Task.FromResult($"Change feed processor '{processorName}' configured for container '{monitoredContainer}'");
    }

    /// <summary>
    /// Stored procedure execution
    /// </summary>
    public async Task<T> ExecuteStoredProcedureAsync<T>(
        string databaseId,
        string containerId,
        string storedProcedureId,
        PartitionKey partitionKey,
        dynamic[] parameters)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        var response = await container.Scripts.ExecuteStoredProcedureAsync<T>(
            storedProcedureId,
            partitionKey,
            parameters);

        _logger.LogInformation("Stored procedure executed. RU: {RU}", response.RequestCharge);
        return response.Resource;
    }

    /// <summary>
    /// Create stored procedure
    /// </summary>
    public async Task CreateStoredProcedureAsync(
        string databaseId,
        string containerId,
        string storedProcedureId,
        string body)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        var storedProcedureProperties = new StoredProcedureProperties
        {
            Id = storedProcedureId,
            Body = body
        };

        await container.Scripts.CreateStoredProcedureAsync(storedProcedureProperties);
        _logger.LogInformation("Stored procedure created: {Id}", storedProcedureId);
    }

    /// <summary>
    /// Get container throughput (RU/s)
    /// </summary>
    public async Task<int?> GetContainerThroughputAsync(string databaseId, string containerId)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        try
        {
            var throughput = await container.ReadThroughputAsync();
            return throughput;
        }
        catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.BadRequest)
        {
            _logger.LogWarning("Container is using serverless or autoscale");
            return null;
        }
    }

    /// <summary>
    /// Scale container throughput
    /// </summary>
    public async Task ScaleContainerThroughputAsync(
        string databaseId,
        string containerId,
        int newThroughput)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);

        await container.ReplaceThroughputAsync(newThroughput);
        _logger.LogInformation("Container throughput scaled to {RU} RU/s", newThroughput);
    }

    /// <summary>
    /// Point read optimization (most efficient - uses ID + partition key)
    /// </summary>
    public async Task<T?> PointReadAsync<T>(
        string databaseId,
        string containerId,
        string id,
        string partitionKeyValue)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);
        
        try
        {
            var response = await container.ReadItemAsync<T>(
                id, 
                new PartitionKey(partitionKeyValue));
            
            _logger.LogInformation("Point read completed. RU: {RU} (typically 1 RU)", response.RequestCharge);
            return response.Resource;
        }
        catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            return default;
        }
    }

    /// <summary>
    /// Cross-partition query (expensive - use sparingly)
    /// </summary>
    public async Task<List<T>> CrossPartitionQueryAsync<T>(
        string databaseId,
        string containerId,
        string query)
    {
        var container = _cosmosClient.GetDatabase(databaseId).GetContainer(containerId);
        
        var queryDefinition = new QueryDefinition(query);
        var queryOptions = new QueryRequestOptions
        {
            MaxItemCount = 100 // Limit results
        };

        var results = new List<T>();
        double totalRU = 0;

        using var iterator = container.GetItemQueryIterator<T>(queryDefinition, requestOptions: queryOptions);

        while (iterator.HasMoreResults)
        {
            var response = await iterator.ReadNextAsync();
            results.AddRange(response);
            totalRU += response.RequestCharge;
        }

        _logger.LogWarning("Cross-partition query executed. Items: {Count}, RU: {RU} (expensive!)", 
            results.Count, totalRU);

        return results;
    }
}
