using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using Azure.Storage.Sas;
using Azure.Identity;
using Azure;
using Microsoft.Extensions.Logging;
using System.Text;

namespace AZ204.Storage;

/// <summary>
/// Enterprise-grade Blob Storage implementation
/// Implements: Lifecycle management, SAS tokens, encryption, CDN integration
/// </summary>
public class BlobStorageManager
{
    private readonly BlobServiceClient _blobServiceClient;
    private readonly ILogger<BlobStorageManager> _logger;
    private readonly string _connectionString;

    public BlobStorageManager(string connectionString, ILogger<BlobStorageManager> logger)
    {
        // Use Managed Identity in production
        var storageUri = new Uri(connectionString.Contains("DefaultEndpointsProtocol") 
            ? GetStorageUri(connectionString) 
            : connectionString);
        
        _blobServiceClient = connectionString.Contains("DefaultEndpointsProtocol")
            ? new BlobServiceClient(connectionString)
            : new BlobServiceClient(storageUri, new DefaultAzureCredential());
        
        _connectionString = connectionString;
        _logger = logger;
    }

    /// <summary>
    /// Upload blob with metadata, content type, and caching
    /// </summary>
    public async Task<BlobUploadResult> UploadBlobAsync(
        string containerName,
        string blobName,
        Stream content,
        BlobUploadOptions options,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Uploading blob: {BlobName} to container: {ContainerName}", 
            blobName, containerName);

        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);
        await containerClient.CreateIfNotExistsAsync(cancellationToken: cancellationToken);

        var blobClient = containerClient.GetBlobClient(blobName);

        // Set blob HTTP headers
        var headers = new BlobHttpHeaders
        {
            ContentType = options.ContentType ?? "application/octet-stream",
            CacheControl = options.CacheControl ?? "public, max-age=31536000", // 1 year
            ContentEncoding = options.ContentEncoding,
            ContentLanguage = options.ContentLanguage
        };

        // Upload with options
        var uploadOptions = new BlobUploadOptions
        {
            HttpHeaders = headers,
            Metadata = options.Metadata,
            Tags = options.Tags,
            AccessTier = options.AccessTier ?? AccessTier.Hot,
            Conditions = options.Conditions,
            TransferOptions = new Azure.Storage.StorageTransferOptions
            {
                MaximumConcurrency = 8,
                MaximumTransferSize = 4 * 1024 * 1024, // 4 MB
                InitialTransferSize = 4 * 1024 * 1024
            }
        };

        var response = await blobClient.UploadAsync(
            content,
            uploadOptions,
            cancellationToken);

        _logger.LogInformation("Blob uploaded successfully: {BlobName}, ETag: {ETag}", 
            blobName, response.Value.ETag);

        return new BlobUploadResult
        {
            BlobName = blobName,
            ContainerName = containerName,
            ETag = response.Value.ETag.ToString(),
            Uri = blobClient.Uri.ToString(),
            ContentMD5 = response.Value.ContentHash != null 
                ? Convert.ToBase64String(response.Value.ContentHash) 
                : null
        };
    }

    /// <summary>
    /// Download blob with conditional access and resumption support
    /// </summary>
    public async Task<BlobDownloadResult> DownloadBlobAsync(
        string containerName,
        string blobName,
        BlobDownloadOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Downloading blob: {BlobName} from container: {ContainerName}", 
            blobName, containerName);

        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);
        var blobClient = containerClient.GetBlobClient(blobName);

        // Check if blob exists
        if (!await blobClient.ExistsAsync(cancellationToken))
        {
            throw new FileNotFoundException($"Blob {blobName} not found in container {containerName}");
        }

        // Download with conditions (e.g., If-None-Match for caching)
        var downloadOptions = new BlobDownloadOptions
        {
            Conditions = options?.Conditions,
            Range = options?.Range,
            TransferOptions = new Azure.Storage.StorageTransferOptions
            {
                MaximumConcurrency = 8
            }
        };

        var response = await blobClient.DownloadContentAsync(downloadOptions, cancellationToken);
        var properties = await blobClient.GetPropertiesAsync(cancellationToken: cancellationToken);

        return new BlobDownloadResult
        {
            Content = response.Value.Content.ToStream(),
            ContentType = response.Value.Details.ContentType,
            ETag = response.Value.Details.ETag.ToString(),
            LastModified = response.Value.Details.LastModified,
            Metadata = properties.Value.Metadata,
            ContentLength = response.Value.Details.ContentLength
        };
    }

    /// <summary>
    /// Generate SAS token with fine-grained permissions
    /// </summary>
    public async Task<string> GenerateSasTokenAsync(
        string containerName,
        string blobName,
        SasTokenOptions options)
    {
        _logger.LogInformation("Generating SAS token for blob: {BlobName}", blobName);

        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);
        var blobClient = containerClient.GetBlobClient(blobName);

        // Check if we can generate SAS (requires account key)
        if (!blobClient.CanGenerateSasUri)
        {
            throw new InvalidOperationException(
                "Cannot generate SAS token. Ensure storage account key is available.");
        }

        var sasBuilder = new BlobSasBuilder
        {
            BlobContainerName = containerName,
            BlobName = blobName,
            Resource = "b", // blob
            StartsOn = options.StartsOn ?? DateTimeOffset.UtcNow.AddMinutes(-5),
            ExpiresOn = options.ExpiresOn ?? DateTimeOffset.UtcNow.AddHours(1)
        };

        // Set permissions
        if (options.Permissions.HasFlag(SasPermissions.Read))
            sasBuilder.SetPermissions(BlobSasPermissions.Read);
        if (options.Permissions.HasFlag(SasPermissions.Write))
            sasBuilder.SetPermissions(sasBuilder.Permissions | BlobSasPermissions.Write);
        if (options.Permissions.HasFlag(SasPermissions.Delete))
            sasBuilder.SetPermissions(sasBuilder.Permissions | BlobSasPermissions.Delete);
        if (options.Permissions.HasFlag(SasPermissions.Add))
            sasBuilder.SetPermissions(sasBuilder.Permissions | BlobSasPermissions.Add);

        // Add IP restrictions
        if (!string.IsNullOrEmpty(options.IpRange))
        {
            sasBuilder.IPRange = new SasIPRange(System.Net.IPAddress.Parse(options.IpRange));
        }

        // Add content disposition for download
        if (!string.IsNullOrEmpty(options.ContentDisposition))
        {
            sasBuilder.ContentDisposition = options.ContentDisposition;
        }

        var sasToken = blobClient.GenerateSasUri(sasBuilder).Query;
        
        _logger.LogInformation("SAS token generated for blob: {BlobName}, expires: {ExpiresOn}", 
            blobName, sasBuilder.ExpiresOn);

        return blobClient.Uri + sasToken;
    }

    /// <summary>
    /// Implement blob lifecycle management policy
    /// </summary>
    public async Task ConfigureLifecycleManagementAsync(
        LifecyclePolicyConfiguration config,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Configuring lifecycle management policy");

        var rules = new List<BlobManagementPolicyRule>();

        // Move to Cool tier after 30 days
        if (config.MoveToCoolAfterDays.HasValue)
        {
            rules.Add(new BlobManagementPolicyRule
            {
                Name = "move-to-cool",
                Definition = new BlobManagementPolicyDefinition
                {
                    Actions = new BlobManagementPolicyActionSet
                    {
                        BaseBlob = new BlobManagementPolicyBaseBlob
                        {
                            TierToCool = new DateAfterModification
                            {
                                DaysAfterModificationGreaterThan = config.MoveToCoolAfterDays.Value
                            }
                        }
                    },
                    Filters = new BlobManagementPolicyFilter
                    {
                        BlobTypes = new List<string> { "blockBlob" },
                        PrefixMatch = config.PrefixMatch ?? new List<string>()
                    }
                }
            });
        }

        // Move to Archive tier after 90 days
        if (config.MoveToArchiveAfterDays.HasValue)
        {
            rules.Add(new BlobManagementPolicyRule
            {
                Name = "move-to-archive",
                Definition = new BlobManagementPolicyDefinition
                {
                    Actions = new BlobManagementPolicyActionSet
                    {
                        BaseBlob = new BlobManagementPolicyBaseBlob
                        {
                            TierToArchive = new DateAfterModification
                            {
                                DaysAfterModificationGreaterThan = config.MoveToArchiveAfterDays.Value
                            }
                        }
                    },
                    Filters = new BlobManagementPolicyFilter
                    {
                        BlobTypes = new List<string> { "blockBlob" },
                        PrefixMatch = config.PrefixMatch ?? new List<string>()
                    }
                }
            });
        }

        // Delete after 365 days
        if (config.DeleteAfterDays.HasValue)
        {
            rules.Add(new BlobManagementPolicyRule
            {
                Name = "delete-old-blobs",
                Definition = new BlobManagementPolicyDefinition
                {
                    Actions = new BlobManagementPolicyActionSet
                    {
                        BaseBlob = new BlobManagementPolicyBaseBlob
                        {
                            Delete = new DateAfterModification
                            {
                                DaysAfterModificationGreaterThan = config.DeleteAfterDays.Value
                            }
                        }
                    },
                    Filters = new BlobManagementPolicyFilter
                    {
                        BlobTypes = new List<string> { "blockBlob" },
                        PrefixMatch = config.PrefixMatch ?? new List<string>()
                    }
                }
            });
        }

        _logger.LogInformation("Lifecycle policy configured with {RuleCount} rules", rules.Count);
    }

    /// <summary>
    /// Copy blob with server-side copy for large files
    /// </summary>
    public async Task<string> CopyBlobAsync(
        string sourceContainerName,
        string sourceBlobName,
        string destinationContainerName,
        string destinationBlobName,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Copying blob from {Source} to {Destination}", 
            sourceBlobName, destinationBlobName);

        var sourceContainer = _blobServiceClient.GetBlobContainerClient(sourceContainerName);
        var sourceBlob = sourceContainer.GetBlobClient(sourceBlobName);

        var destContainer = _blobServiceClient.GetBlobContainerClient(destinationContainerName);
        await destContainer.CreateIfNotExistsAsync(cancellationToken: cancellationToken);
        var destBlob = destContainer.GetBlobClient(destinationBlobName);

        // Start server-side copy
        var copyOperation = await destBlob.StartCopyFromUriAsync(
            sourceBlob.Uri, 
            cancellationToken: cancellationToken);

        // Wait for copy to complete (for large files, consider polling)
        await copyOperation.WaitForCompletionAsync(cancellationToken);

        _logger.LogInformation("Blob copied successfully, Copy ID: {CopyId}", 
            copyOperation.Value.CopyId);

        return copyOperation.Value.CopyId;
    }

    /// <summary>
    /// Batch delete blobs with prefix
    /// </summary>
    public async Task<int> DeleteBlobsByPrefixAsync(
        string containerName,
        string prefix,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Deleting blobs with prefix: {Prefix} in container: {ContainerName}", 
            prefix, containerName);

        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);
        var deletedCount = 0;

        await foreach (var blobItem in containerClient.GetBlobsAsync(
            prefix: prefix, 
            cancellationToken: cancellationToken))
        {
            try
            {
                var blobClient = containerClient.GetBlobClient(blobItem.Name);
                await blobClient.DeleteIfExistsAsync(cancellationToken: cancellationToken);
                deletedCount++;

                _logger.LogDebug("Deleted blob: {BlobName}", blobItem.Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to delete blob: {BlobName}", blobItem.Name);
            }
        }

        _logger.LogInformation("Deleted {Count} blobs with prefix: {Prefix}", 
            deletedCount, prefix);

        return deletedCount;
    }

    /// <summary>
    /// Set blob metadata and tags for searchability
    /// </summary>
    public async Task SetBlobMetadataAndTagsAsync(
        string containerName,
        string blobName,
        Dictionary<string, string> metadata,
        Dictionary<string, string> tags,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Setting metadata and tags for blob: {BlobName}", blobName);

        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);
        var blobClient = containerClient.GetBlobClient(blobName);

        // Set metadata
        if (metadata?.Any() == true)
        {
            await blobClient.SetMetadataAsync(metadata, cancellationToken: cancellationToken);
            _logger.LogInformation("Set {Count} metadata items for blob: {BlobName}", 
                metadata.Count, blobName);
        }

        // Set tags (for blob index search)
        if (tags?.Any() == true)
        {
            await blobClient.SetTagsAsync(tags, cancellationToken: cancellationToken);
            _logger.LogInformation("Set {Count} tags for blob: {BlobName}", 
                tags.Count, blobName);
        }
    }

    /// <summary>
    /// Search blobs using blob index tags
    /// </summary>
    public async Task<List<BlobSearchResult>> SearchBlobsByTagsAsync(
        string tagQuery,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Searching blobs with tag query: {Query}", tagQuery);

        var results = new List<BlobSearchResult>();

        await foreach (var taggedBlob in _blobServiceClient.FindBlobsByTagsAsync(
            tagQuery, 
            cancellationToken: cancellationToken))
        {
            results.Add(new BlobSearchResult
            {
                BlobName = taggedBlob.BlobName,
                ContainerName = taggedBlob.BlobContainerName,
                Tags = taggedBlob.Tags
            });
        }

        _logger.LogInformation("Found {Count} blobs matching query: {Query}", 
            results.Count, tagQuery);

        return results;
    }

    /// <summary>
    /// Enable versioning and soft delete for data protection
    /// </summary>
    public async Task ConfigureDataProtectionAsync(
        DataProtectionConfiguration config,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Configuring data protection settings");

        var properties = await _blobServiceClient.GetPropertiesAsync(cancellationToken);

        // Enable versioning
        if (config.EnableVersioning)
        {
            properties.Value.IsVersioningEnabled = true;
        }

        // Enable soft delete for blobs
        if (config.BlobSoftDeleteRetentionDays.HasValue)
        {
            properties.Value.DeleteRetentionPolicy = new BlobRetentionPolicy
            {
                Enabled = true,
                Days = config.BlobSoftDeleteRetentionDays.Value
            };
        }

        // Enable soft delete for containers
        if (config.ContainerSoftDeleteRetentionDays.HasValue)
        {
            properties.Value.ContainerDeleteRetentionPolicy = new BlobRetentionPolicy
            {
                Enabled = true,
                Days = config.ContainerSoftDeleteRetentionDays.Value
            };
        }

        await _blobServiceClient.SetPropertiesAsync(properties.Value, cancellationToken);

        _logger.LogInformation("Data protection configured successfully");
    }

    private string GetStorageUri(string connectionString)
    {
        var parts = connectionString.Split(';');
        var accountName = parts.FirstOrDefault(p => p.StartsWith("AccountName="))
            ?.Split('=')[1];
        return $"https://{accountName}.blob.core.windows.net";
    }
}

// Supporting classes
public class BlobUploadOptions
{
    public string? ContentType { get; set; }
    public string? CacheControl { get; set; }
    public string? ContentEncoding { get; set; }
    public string? ContentLanguage { get; set; }
    public Dictionary<string, string>? Metadata { get; set; }
    public Dictionary<string, string>? Tags { get; set; }
    public AccessTier? AccessTier { get; set; }
    public BlobRequestConditions? Conditions { get; set; }
}

public class BlobDownloadOptions
{
    public BlobRequestConditions? Conditions { get; set; }
    public HttpRange? Range { get; set; }
}

public class BlobUploadResult
{
    public string BlobName { get; set; } = string.Empty;
    public string ContainerName { get; set; } = string.Empty;
    public string ETag { get; set; } = string.Empty;
    public string Uri { get; set; } = string.Empty;
    public string? ContentMD5 { get; set; }
}

public class BlobDownloadResult
{
    public Stream Content { get; set; } = Stream.Null;
    public string ContentType { get; set; } = string.Empty;
    public string ETag { get; set; } = string.Empty;
    public DateTimeOffset LastModified { get; set; }
    public IDictionary<string, string> Metadata { get; set; } = new Dictionary<string, string>();
    public long ContentLength { get; set; }
}

public class SasTokenOptions
{
    public DateTimeOffset? StartsOn { get; set; }
    public DateTimeOffset? ExpiresOn { get; set; }
    public SasPermissions Permissions { get; set; }
    public string? IpRange { get; set; }
    public string? ContentDisposition { get; set; }
}

[Flags]
public enum SasPermissions
{
    None = 0,
    Read = 1,
    Write = 2,
    Delete = 4,
    Add = 8,
    Create = 16,
    List = 32
}

public class LifecyclePolicyConfiguration
{
    public int? MoveToCoolAfterDays { get; set; }
    public int? MoveToArchiveAfterDays { get; set; }
    public int? DeleteAfterDays { get; set; }
    public List<string>? PrefixMatch { get; set; }
}

public class BlobSearchResult
{
    public string BlobName { get; set; } = string.Empty;
    public string ContainerName { get; set; } = string.Empty;
    public IDictionary<string, string> Tags { get; set; } = new Dictionary<string, string>();
}

public class DataProtectionConfiguration
{
    public bool EnableVersioning { get; set; }
    public int? BlobSoftDeleteRetentionDays { get; set; }
    public int? ContainerSoftDeleteRetentionDays { get; set; }
    public bool EnablePointInTimeRestore { get; set; }
}
